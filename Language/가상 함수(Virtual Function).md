## 가상 함수(Virtual Function)
  가상 함수란 <b>부모 클래스에서 상속 받을 클래스에서 재정의할 것으로 기대하고 정의해놓은 함수</b>를 말한다.
  <br>
  이러한 가상 함수는 자신을 호출하는 객체의 동적 타입에 따라 실제 호출할 함수가 결정된다.
  <br>
  <br>
  가상 함수는 virtual 키워드를 사용하여 선언한다.
  
  ```
  virtual 함수원형();
  ```

  <br>

  ### 바인딩(Binding)
  C++ 컴파일러는 함수를 호출할 때, 어느 블록에 있는 함수를 호출해야 하고, 해당 함수가 정확한 메모리 위치까지 알아야 한다.
  <br>
  이처럼 함수를 호출하는 코드에서 <b>어느 블록에 있는 함수를 실행하라는 의미</b>로 해석하는 것을 바인딩이라고 한다.
  <br>
  <br>
  대부분 함수를 호출하는 코드는 <b>컴파일 타임에 고정된 메모리 주소로 변환</b>된다.
  <br>
  이것을 정적 바인딩(Static Binding)이라고 한다.
  <br>
  C++에서 가상 함수가 아닌 멤버 함수는 모두 정적 바인딩을 하게 된다.
  <br>
  <br>
  하지만 가상 함수의 호출은 <b>컴파일러가 어떤 함수를 호출해야 하는지 미리 알 수 없다</b>.
  <br>
  왜냐하면, <b>가상 함수는 프로그램이 실행될 때 객체를 결정</b>하므로 컴파일 타임에 해당 객체를 특정할 수 없기 때문이다.
  <br>
  따라서 가상 함수의 경우 런 타임에 올바른 함수가 실행될 수 있도록 해야 한다.
  <br>
  이것을 동적 바인딩(Dynamic Binding) 이라고 한다.

  <br>

  ### 가상 함수 테이블(VTBL, Virtual Function Table)
  C++에서는 가상 함수의 정의와 동작 방식만을 규정하고 있으며, 그에 따른 구현은 컴파일러마다 다르다.
  <br>
  하지만 컴파일러가 가상 함수를 다루는 가장 일반적인 방식은 가상 함수 테이블을 이용하는 것이다.
  <br>
  <br>
  C++ 컴파일러는 각각의 객체마다 가상 함수 테이블을 가리키는 포인터를 저장하기 위한 숨겨진 멤버를 하나 추가한다.
  <br>
  이와 함께 가상 함수를 단 하나라도 가지는 클래스에 대해서 가상 함수 테이블을 작성한다.
  <br>
  이렇게 작성된 가상 함수 테이블에는 해당 클래스의 객체들을 위해 선언된 가상 함수들의 주소가 저장되게 된다.
  <br>
  <br>
  가상 함수를 호출하면, C++ 프로그램은 가상 함수 테이블에 접근하여 자신이 필요한 함수의 주소를 찾아 호출하게 된다.
  <br>
  가상 함수를 사용하면 이처럼 함수의 호출 과정이 복잡해지므로, 메모리와 실행 속도 측면에서 부담을 가지게 된다.
  <br>
  따라서 C++에서 <b>기본 바인딩은 정적 바인딩이며, 필요한 경우에만 가상 함수로 선언하도록</b> 하고 있다.
  > 파생 클래스가 재정의할 가능성이 있는 함수는 모두 가상 함수로 선언하는 편이 좋음

  <br>

  ### 순수 가상 함수(Pure Virtual Function)
  C++에서 가상 함수란 파생 클래스에서 재정의할 것으로 기대하는 멤버 함수를 의미한다.
  <br>
  따라서 가상 함수는 반드시 재정의해야만 하는 함수가 아닌, 재정의가 가능한 함수를 가리킨다.
  <br>
  <br>
  이와 달리 순수 가상 함수는 파생 함수는 파생 클래스에서 반드시 재정의해야 하는 멤버 함수를 의미한다.
  <br>
  이러한 가상 함수는 일반적으로 함수의 동작을 정의하는 본체를 가지고 있지 않다.
  <br>
  따라서 파생 클래스에서 재저으이하지 않으면 사용할 수 없다.
  <br>
  <br>
  아래와 같이 함수만 있고 본체가 없다는 의미로 함수 선언부 끝에 "=0"을 추가한다.

  ```
  virtual 함수 원형=0;
  ```
